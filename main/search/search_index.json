{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"contributing/code/","title":"Code","text":""},{"location":"contributing/code/#pre-requisites","title":"Pre-requisites","text":"<p>You will need to have the following installed:</p> <ul> <li>Nix</li> <li>Direnv</li> </ul> <p>Important</p> <p>We use a Flake-based workflow. You can certainly develop for <code>nixos-facter</code> without Flakes and leverage much of what is listed below, but it is left up to the reader to determine how to make that work.</p>"},{"location":"contributing/code/#go-development","title":"Go development","text":"<p>The default devshell is a modified version of the underlying Nix derivation for <code>nixos-facter</code>. As such, it provides all the necessary tooling and utilities for working on <code>nixos-facter</code>.</p> nix/devshells/default.nix<pre><code>{\n  perSystem,\n  pkgs,\n  ...\n}:\nperSystem.self.nixos-facter.overrideAttrs (old: {\n  GOROOT = \"${old.go}/share/go\";\n  nativeBuildInputs =\n    old.nativeBuildInputs\n    ++ [\n      perSystem.gomod2nix.default\n      pkgs.enumer\n      pkgs.delve\n      pkgs.pprof\n      pkgs.gotools\n      pkgs.golangci-lint\n      pkgs.cobra-cli\n      pkgs.fx # json tui\n      pkgs.goreleaser\n      perSystem.hwinfo.default\n    ];\n  shellHook = ''\n    # this is only needed for hermetic builds\n    unset GO_NO_VENDOR_CHECKS GOSUMDB GOPROXY GOFLAGS\n  '';\n})\n</code></pre> <p>Direnv should load this by default when entering the root of the repository.</p> <p>For the most part, you should be able to develop normally as you would any other Go program.</p> <p>Important</p> <p>When you have completed making any changes and have tested it as you would any other Go program, it is important to ensure it works when run as a Nix package.</p> <p>This can be done with <code>nix run .# -- &lt;args&gt;</code>, which will build the Nix derivation and execute the resultant <code>nixos-facter</code> binary.</p>"},{"location":"contributing/code/#formatting","title":"Formatting","text":"<p>We use treefmt and treefmt-nix to format the repository by running <code>nix fmt</code> from the root directory.</p> nix/formatter.nix<pre><code>{\n  pkgs,\n  inputs,\n  ...\n}:\ninputs.treefmt-nix.lib.mkWrapper pkgs {\n  projectRootFile = \".git/config\";\n\n  programs = {\n    alejandra.enable = true;\n    deadnix.enable = true;\n    gofumpt.enable = true;\n    prettier.enable = true;\n    statix.enable = true;\n  };\n\n  settings = {\n    global.excludes = [\n      \"LICENSE\"\n      # unsupported extensions\n      \"*.{gif,png,svg,tape,mts,lock,mod,sum,toml,env,envrc,gitignore}\"\n    ];\n\n    formatter = {\n      deadnix = {\n        priority = 1;\n      };\n\n      statix = {\n        priority = 2;\n      };\n\n      alejandra = {\n        priority = 3;\n      };\n\n      prettier = {\n        options = [\n          \"--tab-width\"\n          \"4\"\n        ];\n        includes = [\"*.{css,html,js,json,jsx,md,mdx,scss,ts,yaml}\"];\n      };\n    };\n  };\n}\n</code></pre>"},{"location":"contributing/code/#checks","title":"Checks","text":"<p>Running <code>nix flake check</code> will build all the devshells and Nix packages, as well as check the formatting with treefmt and any other Flake checks that have been configured.</p>"},{"location":"contributing/code/#documentation","title":"Documentation","text":"<p>When making changes, it is important to add or update any relevant sections in the documentation within the same pull request.</p> <p>For more information see the next section.</p>"},{"location":"contributing/docs/","title":"Documentation","text":"<p>There is a separate devshell called <code>docs</code> which is provided for working with the docs locally.</p> <p>It can be entered by running: <code>nix develop .#docs</code></p> nix/devshells/docs.nix<pre><code>{\n  pkgs,\n  perSystem,\n  ...\n}:\npkgs.mkShellNoCC {\n  packages = with pkgs;\n  # Pop an empty shell on systems that aren't supported by godoc\n    lib.optionals (perSystem.godoc ? default)\n    ([\n        perSystem.godoc.default\n        (pkgs.writeScriptBin \"gen-reference\" ''\n          out=\"./docs/content/reference/go_doc\"\n          godoc -c -o $out .\n        '')\n        (pkgs.writeScriptBin \"mkdocs\" ''\n          # generate reference docs first\n          gen-reference\n          # execute the underlying command\n          ${pkgs.mkdocs}/bin/mkdocs \"$@\"\n        '')\n      ]\n      ++ (with pkgs.python3Packages; [\n        mike\n        mkdocs-material\n      ]));\n}\n</code></pre> <p>The docs are based on MkDocs and the MkDocs Material theme. You will find its configuration and content in the following locations:</p> <ul> <li><code>mkdocs.yaml</code></li> <li><code>./docs</code></li> </ul>"},{"location":"contributing/docs/#serve-locally","title":"Serve locally","text":"<p>To serve the docs locally run <code>mkdocs serve</code> from the root of the repository:</p> <pre><code>\u276f mkdocs serve\nINFO    -  Building documentation...\nINFO    -  Cleaning site directory\nWARNING -  The following pages exist in the docs directory, but are not included in the \"nav\" configuration:\n             - index.md\nINFO    -  Documentation built in 0.26 seconds\nINFO    -  [16:22:36] Watching paths for changes: 'docs/content', 'mkdocs.yml'\nINFO    -  [16:22:36] Serving on http://127.0.0.1:8000/nixos-facter/\n</code></pre>"},{"location":"contributing/docs/#versioning-publication","title":"Versioning &amp; Publication","text":"<p>Versioning of the docs is managed through mike.</p> <p>It is responsible for managing the structure of the <code>gh-pages</code> branch in the repository, which Github Pages is configured to serve from.</p> <p>Note</p> <p>More information about versioning with MkDocs Material and mike can be found here.</p> <p>There is a github workflow, <code>.github/workflows/gh-pages.yml</code> which is responsible for publishing the docs. It does the following:</p> <ul> <li>On merge to <code>main</code>, the docs version main is updated.</li> <li>When a new tag is created of the form <code>v.&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;</code> a docs version <code>v&lt;major&gt;.&lt;minor&gt;</code> is created and the     latest alias is updated to point to this.</li> </ul> <p>The idea is that users will land on the latest released version of the docs by default, with <code>main</code> being available if they wish to read about unreleased features and changes.</p> <p>To preview the versions locally you can use <code>mike serve</code> instead of <code>mkdocs serve</code>.</p> <p>Warning</p> <p>Be sure to have fetched the latest changes for the <code>gh-pages</code> branch first. This is especially important if you are using <code>mike</code> locally to make manual changes to the published site.</p>"},{"location":"getting-started/generate-report/","title":"Generate a report","text":"<p>To generate a report, you will need to have Nix installed on the target machine.</p> <pre><code>sudo nix run \\\n  --option experimental-features \"nix-command flakes\" \\\n  --option extra-substituters https://numtide.cachix.org \\\n  --option extra-trusted-public-keys numtide.cachix.org-1:2ps1kLBUWjxIneOy1Ik6cQjb41X0iXVXeHigGmycPPE= \\\n  github:numtide/nixos-facter -- -o facter.json\n</code></pre> <p>Note</p> <p>In the near-future we will add nixos-facter to nixpkgs. Until then, we recommend using the Numtide Binary Cache to avoid having to build everything from scratch.</p> <p>This will scan your system and produce a JSON-based report in a file named <code>facter.json</code>:</p> facter.json<pre><code>{\n  \"version\": 2, // (1)!\n  \"system\": \"x86_64-linux\", // (2)!\n  \"virtualisation\": \"none\", // (3)!\n  \"hardware\": { // (4)!\n    \"bios\": { ... },\n    \"bluetooth\": [ ... ],\n    \"bridge\": [ ... ],\n    \"chip_card\": [ ... ] ,\n    \"cpu\": [ ... ],\n    \"disk\": [ ... ],\n    \"graphics_card\": [ ... ],\n    \"hub\": [ ... ],\n    \"keyboard\": [ ... ],\n    \"memory\": [ ... ],\n    \"monitor\": [ ... ],\n    \"mouse\": [ ... ],\n    \"network_controller\": [ ... ],\n    \"network_interface\": [ ... ],\n    \"sound\": [ ... ],\n    \"storage_controller\": [ ... ],\n    \"system\": [ ... ],\n    \"unknown\": [ ... ],\n    \"usb_controller\": [ ... ]\n  },\n  \"smbios\": { // (5)!\n    \"bios\": { ... },\n    \"board\": { ... },\n    \"cache\": [ ... ],\n    \"chassis\": { ... },\n    \"config\": { ... },\n    \"language\": { ... },\n    \"memory_array\": [ ... ],\n    \"memory_array_mapped_address\": [ ... ],\n    \"memory_device\": [ ... ],\n    \"memory_device_mapped_address\": [ ... ],\n    \"memory_error\": [ ... ],\n    \"onboard\": [ ... ],\n    \"port_connector\": [ ... ],\n    \"processor\": [ ... ],\n    \"slot\": [ ... ],\n    \"system\": { ... }\n  }\n}\n</code></pre> <ol> <li>Used to track major breaking changes in the report format.</li> <li>Architecture of the target machine.</li> <li>Indicates whether the report was generated inside a virtualised environment, and if so, what type.</li> <li>All the various bits of hardware that could be detected.</li> <li>System Management BIOS information if available.</li> </ol> <p>Tip</p> <p>To use this report in your NixOS configuration, have a look at NixOS Facter Modules.</p>"}]}